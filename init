#!/usr/bin/ruby

require 'socket'

def do_cmd(*cmd)
  ctl = UNIXSocket.open('/run/initctl')
  ctl.puts(cmd.join(' '))
  loop do
    r = ctl.readline.chomp
    exit if r == 'done'
    puts(r)
  end
end

case ARGV[0]
when 'poweroff', 'restart', 'halt'
  do_cmd(ARGV[0].to_sym)
when 'status'
  do_cmd(ARGV.shift.to_sym, *ARGV)
end

$daemons = {}

Signal.trap(:SIGCHLD) do
  loop do
    begin
      status = Process.wait(-1, Process::WNOHANG)
      key = $daemons.key(status)
      $daemons.delete(key) if key
      break if status == nil
    rescue Errno::ECHILD
      break
    end
  end
end

def get_mountinfo
  mounts = {}
  return {} unless File.exists?('/proc/self/mountinfo')
  File.open('/proc/self/mountinfo').each do |l|
    tmp = l.chomp.split
    id, pid, major_minor, root, mount_point, mount_opts = tmp.shift(6)
    mark = tmp.index('-')
    tmp.shift(mark + 1)
    fstype, _ = tmp
    mounts[mount_point] = { :opts => mount_opts, :fs => fstype }
  end
  mounts
end

def get_fstab
  fstab = {}
  File.open('/etc/fstab').each do |l|
    case l
    when /^#/
    when /^$/
    else
      dev, dir, type, opts = l.chomp.split
      fstab[dir] = true
    end
  end
  fstab
end

def calc_columns
  rows, cols = `stty size`.chomp.split.map(&:to_i)
  $status_col = cols - 6
end

C_CLEAR = "\e[m" # clear text
C_MAIN = "\e[;1m" # main text
C_OTHER = "\e[1;34m" # prefix & brackets
C_BUSY = "\e[;36m" # busy
C_DONE = C_MAIN
C_FAIL = "\e[1;31m" # failed

def colorize(*args)
  args + [C_CLEAR, " "]
end

def title(name)
  print *colorize(C_OTHER, ":: ", C_MAIN, name)
end

def status(name)
  color_status = eval "C_#{name}"
  print "\e[", $status_col, 'G'
  print *colorize(C_OTHER, '[', color_status, name, C_OTHER, ']')
end

def action(name)
  title name
  status "BUSY"
  begin
    yield ? status("DONE") : status("FAIL")
  rescue => msg
    print msg
    status("FAIL")
  end
  puts
end

NETFS = %w[nfs nfs4 smbfs cifs codafs ncpfs shfs fuse fuseblk glusterfs davfs fuse.glusterfs]
VIRTFS = %w[proc sysfs tmpfs devtmpfs devpts]

def init
  def is_mounted(path)
    return false unless File.directory?(path)
    path = File.realpath(path)
    a = File.stat(path)
    b = File.stat(path + '/..')
    return (a.dev != b.dev) || (a.ino == b.ino)
  end

  def mount(type, device, dir, opts)
    return if is_mounted(dir)
    Dir.mkdir(dir) unless File.directory?(dir)
    system('mount', '-t', type, device, dir, '-o', opts)
  end

  calc_columns

  action 'Mounting virtual file-systems' do
    mount('proc', 'proc', '/proc', 'nosuid,noexec,nodev')
    mount('sysfs', 'sys', '/sys', 'nosuid,noexec,nodev')
    mount('tmpfs', 'run', '/run', 'mode=0755,nosuid,nodev')
    mount('devtmpfs', 'dev', '/dev', 'mode=0755,nosuid')
    mount('devpts', 'devpts', '/dev/pts', 'mode=0620,gid=5,nosuid,noexec')
    mount('tmpfs', 'shm', '/dev/shm', 'mode=1777,nosuid,nodev')
  end

  action 'Setting hostname' do
    hostname = File.read('/etc/hostname').chomp
    File.write('/proc/sys/kernel/hostname', hostname)
  end

  if not File.exists?('/run/initramfs/root-fsck')
    mounts = get_mountinfo

    # remount root ro to allow for fsck later on, we remount now to make sure
    # nothing can open files rw on root which would block a remount
    if mounts['/'][:opts] != 'ro'
      action "Mounting root read-only" do
        system('mount', '/', '-o', 'remount,ro')
      end
    end
  end

  # log all console messages
  system('bootlogd', '-p', '/run/bootlogd.pid')

  action 'Adjusting system time and setting kernel time zone' do
    system('hwclock', '--systz')
  end

  action 'Starting udev daemon' do
    system('/usr/lib/systemd/systemd-udevd', '--daemon')
  end

  action 'Triggering udev uevents' do
    system('udevadm', 'trigger', '--action=add', '--type=subsystems')
    system('udevadm', 'trigger', '--action=add', '--type=devices')
  end

  action 'Loading user-specified modules' do
    system('/usr/lib/systemd/systemd-modules-load')
  end

  action 'Waiting for udev uevents to be processed' do
    system('udevadm', 'settle')
  end

  calc_columns

  # this must be done after udev has loaded the KMS modules
  action 'Configuring virtual consoles' do
    system('/usr/lib/systemd/systemd-vconsole-setup')
  end

  if not File.directory?('/sys/class/net/lo')
    action 'Bringing up loopback interface' do
      system('ip', 'link', 'set', 'up', 'dev', 'lo')
    end
  end

  if File.executable?('/sbin/fsck')
    action 'Checking filesystems' do
      cmds = File.read('/proc/cmdline').chomp.split
      if File.file?('/forcefsck') or cmds.member?('forcefsck')
        force = true
      elsif File.file?('/fastboot') or cmds.member?('fastboot')
        next
      end
      except = NETFS.map { |e| 'no' + e }.join(',')
      cmd = [ 'fsck', '-A', '-T', '-a', '-t', except + ',noopts=_netdev' ]
      cmd += [ '--', '-f' ] if force
      system(*cmd, 1 => File::NULL)
      $?.exitstatus <= 1
    end
  end

  action 'Remounting root and virtual file-systems' do
    system('/usr/lib/systemd/systemd-remount-fs')
  end

  action 'Mounting local filesystems' do
    except = NETFS.map { |e| 'no' + e }.join(',')
    system('mount', '-a', '-t', except, '-O', 'no_netdev')
  end

  action 'Activating swap' do
    system('swapon', '-a')
  end

  action 'Initializing random seed' do
    system('/usr/lib/systemd/systemd-random-seed', 'load')
  end

  action 'Manage temporary files' do
    system('systemd-tmpfiles', '--create', '--remove', '--clean')
  end

  action 'Saving dmesg log' do
    begin
      restricted = File.read('/proc/sys/kernel/dmesg_restrict').to_i == 1
    rescue Errno::ENOENT
      restricted = false
    end

    File.open('/var/log/dmesg.log', 'w', restricted ? 0600 : 0644) do |f|
      f.write `dmesg`
    end
  end

  # Load sysctl config files
  system('/usr/lib/systemd/systemd-sysctl')

  # Load additional binary formats
  dir = '/proc/sys/fs/binfmt_misc'
  if not is_mounted(dir)
    fstab = get_fstab()

    if fstab[dir]
      system('mount', '/proc/sys/fs/binfmt_misc')
    else
      system('mount', '-t', 'binfmt_misc', 'binfmt', '/proc/sys/fs/binfmt_misc')
    end
  end

  system('/usr/lib/systemd/systemd-binfmt')

end

def shutdown
  def killall

    def allgone?()
      Dir.glob('/proc/*').each do |e|
        pid = File.basename(e).to_i
        begin
          next if pid < 2
          # Is it a kernel process?
          next if File.read('/proc/%i/cmdline' % pid).empty?
        rescue Errno::ENOENT
        end
        return false
      end
      return true
    end

    def wait_until(timeout = 2, interval = 0.25)
      start = Time.now
      begin
        break true if yield
        sleep(interval)
      end while (Time.now - start) < timeout
    end

    ok = false

    action 'Sending SIGTERM to processes' do
      Process.kill(:SIGTERM, -1)
      ok = wait_until(10) { allgone? }
    end

    return if ok

    action 'Sending SIGKILL to processes' do
      Process.kill(:SIGKILL, -1)
      ok = wait_until(15) { allgone? }
    end

  end

  system('/etc/rc.local.shutdown') if File.executable?('/etc/rc.local.shutdown')

  action 'Saving random seed' do
    system('/usr/lib/systemd/systemd-random-seed', 'save')
  end

  system('halt', '-w')

  action 'Shutting down udev' do
    system('udevadm', 'control', '--exit')
  end

  # Kill everything
  killall

  action 'Unmounting real filesystems' do
    except = (NETFS + VIRTFS).map { |e| 'no' + e }.join(',')
    system('umount', '-a', '-t', except, '-O', 'no_netdev')
  end

  action 'Deactivating swap' do
    system('swapoff', '-a')
  end

  sys_sync()

end

init

begin
  File.delete('/run/nologin')
rescue Errno::ENOENT
end

ARGV.each do |e|
  case e
  when 'emergency'
    $emergency = true
  end
end

system('/etc/rc.local') if File.executable?('/etc/rc.local')

def start(id, cmd)
  pid = fork do
    Process.setsid()
    exec(*cmd)
  end
  $daemons[id] = pid
end

def start_with_socket(id, stream, cmd, managed: true)

  if stream.is_a?(Integer)
    server = TCPServer.new(stream)
  else
    server = UNIXServer.new(stream)
  end

  Thread.new do
    if managed
      IO.select([server])
      pid = fork do
        env = {}
        env['LISTEN_PID'] = $$.to_s
        env['LISTEN_FDS'] = 1.to_s
        Process.setsid()
        exec(env, *cmd, 3 => server)
      end
      $daemons[id] = pid
    else
      loop do
        socket = server.accept
        system(*cmd, :in => socket, :out => socket)
      end
    end
  end

end

if $emergency
  start('agetty1', %w[agetty tty1 --noclear --autologin root])
else
  (1..5).each do |n|
    start("agetty#{n}", %W[agetty tty#{n}])
  end
  start('slim', %w[slim -nodaemon])

  Dir.mkdir('/run/dbus', 0755) unless File.exists?('/run/dbus')
  start('dbus', %w[dbus-daemon --system --nofork --nopidfile])

  start_with_socket('sshd', 22, %w[/usr/bin/sshd -i], managed: false)
  start_with_socket('uuid', '/run/uuidd/request', %w[uuidd --socket-activation --timeout 60])
end

def sys_reboot(cmd)
  map = { poweroff: 0x4321fedc, restart: 0x01234567, halt: 0xcdef0123 }
  syscall(169, 0xfee1dead, 537993216, map[cmd])
end

def sys_sync
  syscall(162)
end

begin
  server = UNIXServer.open('/run/initctl')
rescue Errno::EADDRINUSE
  File.delete('/run/initctl')
  retry
end

loop do
  ctl = server.accept
  args = ctl.readline.chomp.split
  cmd = args.shift.to_sym
  case cmd
  when :poweroff, :restart, :halt
    shutdown
    sys_reboot(cmd)
  when :status
    if args.empty?
      $daemons.each do |key, value|
        ctl.puts('%s: ok' % key)
      end
    else
      ctl.puts($daemons[args.first] ? 'ok' : 'dead')
    end
    ctl.puts('done')
  end
end
