#!/usr/bin/ruby

require 'socket'

def do_cmd(*cmd)
  ctl = UNIXSocket.open('/run/initctl')
  ctl.puts(cmd.join(' '))
  puts(ctl.readline.chomp)
  exit
end

case ARGV[0]
when 'poweroff', 'restart', 'halt'
  do_cmd(ARGV[0].to_sym)
end

Signal.trap(:SIGCHLD) do
  loop do
    begin
      status = Process.wait(-1, Process::WNOHANG)
      break if status == nil
    rescue Errno::ECHILD
      break
    end
  end
end

def action(name)
  print(name)
  begin
    yield
  rescue => e
    print(' (error: %s)' % e)
  end
  puts
end

NETFS = %w[nfs nfs4 smbfs cifs codafs ncpfs shfs fuse fuseblk glusterfs davfs fuse.glusterfs]
VIRTFS = %w[proc sysfs tmpfs devtmpfs devpts]

def init
  def mount(type, device, dir, opts)
    Dir.mkdir(dir) unless File.directory?(dir)
    system('mount', '-t', type, device, dir, '-o', opts)
  end

  action 'Mounting virtual file-systems' do
    mount('proc', 'proc', '/proc', 'nosuid,noexec,nodev')
    mount('sysfs', 'sys', '/sys', 'nosuid,noexec,nodev')
    mount('tmpfs', 'run', '/run', 'mode=0755,nosuid,nodev')
    mount('devtmpfs', 'dev', '/dev', 'mode=0755,nosuid')
    mount('devpts', 'devpts', '/dev/pts', 'mode=0620,gid=5,nosuid,noexec')
    mount('tmpfs', 'shm', '/dev/shm', 'mode=1777,nosuid,nodev')
  end

  action 'Setting hostname' do
    hostname = File.read('/etc/hostname').chomp
    File.write('/proc/sys/kernel/hostname', hostname)
  end

  action 'Mounting local filesystems' do
    except = NETFS.map { |e| 'no' + e }.join(',')
    system('mount', '-a', '-t', except, '-O', 'no_netdev')
  end

  action 'Manage temporary files' do
    system('systemd-tmpfiles', '--create', '--remove', '--clean')
  end

end

def shutdown
  def killall

    def allgone?()
      Dir.glob('/proc/*').each do |e|
        pid = File.basename(e).to_i
        begin
          next if pid < 2
          # Is it a kernel process?
          next if File.read('/proc/%i/cmdline' % pid).empty?
        rescue Errno::ENOENT
        end
        return false
      end
      return true
    end

    def wait_until(timeout = 2, interval = 0.25)
      start = Time.now
      begin
        break true if yield
        sleep(interval)
      end while (Time.now - start) < timeout
    end

    ok = false

    action 'Sending SIGTERM to processes' do
      Process.kill(:SIGTERM, -1)
      ok = wait_until(10) { allgone? }
      raise 'Failed' unless ok
    end

    return if ok

    action 'Sending SIGKILL to processes' do
      Process.kill(:SIGKILL, -1)
      ok = wait_until(15) { allgone? }
      raise 'Failed' unless ok
    end

  end

  # Kill everything
  killall

  action 'Unmounting real filesystems' do
    except = (NETFS + VIRTFS).map { |e| 'no' + e }.join(',')
    system('umount', '-a', '-t', except, '-O', 'no_netdev')
  end

  sys_sync()

end

init

begin
  File.delete('/run/nologin')
rescue Errno::ENOENT
end

Process.spawn('agetty', 'tty1')

def sys_reboot(cmd)
  map = { poweroff: 0x4321fedc, restart: 0x01234567, halt: 0xcdef0123 }
  syscall(169, 0xfee1dead, 537993216, map[cmd])
end

def sys_sync
  syscall(162)
end

begin
  server = UNIXServer.open('/run/initctl')
rescue Errno::EADDRINUSE
  File.delete('/run/initctl')
  retry
end

loop do
  ctl = server.accept
  cmd = ctl.readline.chomp.to_sym
  shutdown
  sys_reboot(cmd)
end
